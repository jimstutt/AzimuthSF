name: directory-tree
version: 0.10.1
id: directory-tree-0.10.1-92349fe23074e43757eafc2676a885de
license: BSD3
copyright: (c) 2011, Brandon Simmons <brandon.m.simmons@gmail.com>
maintainer: Brandon Simmons <brandon.m.simmons@gmail.com>
stability:
homepage: http://coder.bsimmons.name/blog/2009/05/directory-tree-module-released/
package-url:
synopsis: A simple directory-like tree datatype, with useful IO functions
description: A simple directory-like tree datatype, with useful IO functions and Foldable and Traversable instance
             .
             Provides a simple data structure mirroring a directory tree on the
             filesystem, as well as useful functions for reading and writing
             file and directory structures in the IO monad.
             .
             Importing the library and optional (useful) Foldable and Traverable libraries:
             .
             > import System.Directory.Tree
             > import qualified Data.Foldable as F
             > import qualified Data.Traversable as T
             .
             Write a hand-made directory tree of textfiles (strings) to the disk.
             Simulates creating a new user Tux's home directory on a unix machine:
             .
             > writeDirectory$ "/home" :/ Dir "Tux" [File "README" "Welcome!"]
             .
             "read" a directory by opening all the files at a filepath with readFile,
             returning an 'AnchoredDirTree String' (d2). Then check for any IO failures:
             .
             > do (base :/ d2) <- readDirectory "../parent_dir/dir2/"
             >    let failed = anyFailed d2
             >    if failed then ...
             .
             Use Foldable instance function to concat a directory 'dir' of text files into a
             single file under the same directory:
             .
             > do (b :/ dt) <- readDirectory dir
             >    let f = F.concat dt
             >    return$ b :/ File "ALL_TEXT" f
             .
             Open all the files in the current directory as lazy bytestrings, ignoring
             the base path in Anchored wrapper:
             .
             > import qualified Data.ByteString.Lazy as B
             > do (_ :/ dTree) <- readDirectoryWith B.readFile "./"
             .
             This version also offers an experimental function `readDirectoryWithL` that does
             lazy directory IO, allowing you to treat the returned `DirTree` as if it were a
             normal lazily-generated data structure.
             .
             For example, the following does only the amount of IO necessary to list the file
             names of the children of the root directory, similar to "ls /":
             .
             > do d <- readDirectoryWithL readFile "/"
             >    mapM_ (putStrLn . name) $ contents $ free d
             .
             Any ideas or suggestions for improvements are most welcome :-)
             .
category: Data, System
author: Brandon Simmons
exposed: True
exposed-modules: System.Directory.Tree
hidden-modules:
trusted: False
import-dirs: C:\Users\jim\snap-boiler-plate/directory-tree-0.10.1\ghc-7.4.1
library-dirs: C:\Users\jim\snap-boiler-plate/directory-tree-0.10.1\ghc-7.4.1
hs-libraries: HSdirectory-tree-0.10.1
extra-libraries:
extra-ghci-libraries:
include-dirs:
includes:
depends: base-4.5.0.0-597748f6f53a7442bcae283373264bb6
         directory-1.1.0.2-0270278088d4b2588b52cbec49af4cb7
         filepath-1.3.0.0-a0928db5e84f98f74207b69b18d7b311
hugs-options:
cc-options:
ld-options:
framework-dirs:
frameworks:
haddock-interfaces: C:\Users\jim\snap-boiler-plate/\doc\directory-tree-0.10.1\html\directory-tree.haddock
haddock-html: C:\Users\jim\snap-boiler-plate/\doc\directory-tree-0.10.1\html
